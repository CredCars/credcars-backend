name: CI/CD NestJS ‚Üí Elastic Beanstalk

on:
  push:
    branches:
      - staging
      - main

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    env:
      MONGODB_URI: ${{ vars.MONGODB_URI }}
      JWT_SECRET: ${{ vars.JWT_SECRET }}
      JWT_REFRESH_SECRET: ${{ vars.JWT_REFRESH_SECRET }}
      JWT_EXPIRES_IN: ${{ vars.JWT_EXPIRES_IN }}
      JWT_REFRESH_EXPIRES_IN: ${{ vars.JWT_REFRESH_EXPIRES_IN }}
      NODE_ENV: test
      ALLOWED_ORIGINS: ${{ vars.ALLOWED_ORIGINS }}
      FRONTEND_URL: ${{ vars.FRONTEND_URL }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Cache node modules
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}

      - run: npm ci
      - run: npm run lint
      # - run: npm test -- --coverage
      - run: npm run build

      - name: Package for Elastic Beanstalk
        run: |
          zip -r app.zip dist package.json package-lock.json Procfile .ebextensions -x "*.git*" || true
          unzip -l app.zip | head -20

      - uses: actions/upload-artifact@v4
        with:
          name: eb-artifact
          path: app.zip

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test
    environment: ${{ github.ref_name == 'main' && 'production' || 'staging' }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: eb-artifact
          path: .

      - uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ vars.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ vars.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      # Determine environment
      - name: Set environment variables
        run: |
          if [[ "${GITHUB_REF##*/}" == "main" ]]; then
            ENV="production"
            EB_ENV="Credcars-backend-production-env"
            EB_GREEN_ENV="Credcars-backend-production-green-env"
          else
            ENV="staging"
            EB_ENV="Credcars-backend-staging-env"
          fi
          echo "ENV=$ENV" >> $GITHUB_ENV
          echo "EB_ENV=$EB_ENV" >> $GITHUB_ENV
          echo "EB_GREEN_ENV=$EB_GREEN_ENV" >> $GITHUB_ENV
          echo "TERRAFORM_DIR=infra/terraform/$ENV" >> $GITHUB_ENV

      - name: Prepare Terraform working directory
        run: |
          mkdir -p $TERRAFORM_DIR
          mv app.zip "$TERRAFORM_DIR/app-${ENV}.zip"
          echo "APP_ZIP_PATH=app-${ENV}.zip" >> $GITHUB_ENV

      - name: Create $ENV.tfvars from environment variables
        run: |
          cd $TERRAFORM_DIR
          cat > $ENV.tfvars <<EOF
          database_url             = "${MONGODB_URI}"
          jwt_secret               = "${JWT_SECRET}"
          jwt_refresh_secret       = "${JWT_REFRESH_SECRET}"
          jwt_expires_in           = "${JWT_EXPIRES_IN}"
          jwt_refresh_expires_in   = "${JWT_REFRESH_EXPIRES_IN}"
          allowed_origins          = "${ALLOWED_ORIGINS}"
          frontend_url             = "${FRONTEND_URL}"
          env                      = "${ENV}"
          EOF
          echo "‚úÖ $ENV.tfvars created successfully"

      - name: Terraform Init
        run: |
          cd $TERRAFORM_DIR
          terraform init -reconfigure

      # ‚úÖ New dynamic import logic (no manual steps)
      - name: Import existing Elastic Beanstalk resources if needed
        run: |
          cd $TERRAFORM_DIR
          echo "üöÄ Checking for existing Beanstalk environment..."
          if aws elasticbeanstalk describe-environments \
            --application-name Credcars-backend \
            --environment-names $EB_ENV \
            --no-include-deleted 2>/dev/null | grep -q "EnvironmentName"; then
            echo "‚úÖ Existing environment found. Importing into Terraform state..."

            terraform import -var-file=$ENV.tfvars aws_elastic_beanstalk_application.app Credcars-backend || true
            terraform import -var-file=$ENV.tfvars aws_elastic_beanstalk_environment.env Credcars-backend/$EB_ENV || true
            terraform import -var-file=$ENV.tfvars aws_iam_role.eb_service_role aws-elasticbeanstalk-service-role || true
            terraform import -var-file=$ENV.tfvars aws_iam_role.eb_ec2_role aws-elasticbeanstalk-ec2-role || true
            terraform import -var-file=$ENV.tfvars aws_iam_instance_profile.eb_ec2_instance_profile aws-elasticbeanstalk-ec2-role || true
          else
            echo "üÜï No existing environment found. Terraform will create it."
          fi

      - name: Set dynamic version label
        run: |
          TIMESTAMP=$(date +%s)
          echo "APP_VERSION=v1-${ENV}-${TIMESTAMP}" >> $GITHUB_ENV
          echo "‚úÖ Using version label: v1-${ENV}-${TIMESTAMP}"

      - name: Terraform Apply
        run: |
          cd $TERRAFORM_DIR
          terraform apply -auto-approve \
          -var "app_zip_path=${APP_ZIP_PATH}" \
          -var "app_version=${APP_VERSION}" \
          -var-file="$ENV.tfvars"

      # (rest of your EB deploy and cleanup logic unchanged)
      - name: Deploy to Elastic Beanstalk
        run: |
          VERSION_LABEL="v-${GITHUB_RUN_NUMBER}-$ENV"
          aws s3 cp "$TERRAFORM_DIR/app-${ENV}.zip" s3://elasticbeanstalk-${{ vars.AWS_REGION }}-${{ vars.AWS_ACCOUNT_ID }}/app-${ENV}.zip

          aws elasticbeanstalk create-application-version \
            --application-name Credcars-backend \
            --version-label $VERSION_LABEL \
            --source-bundle S3Bucket="elasticbeanstalk-${{ vars.AWS_REGION }}-${{ vars.AWS_ACCOUNT_ID }}",S3Key="app-${ENV}.zip"

          if [ "$ENV" = "production" ]; then
            echo "Deploying to GREEN environment first..."
            aws elasticbeanstalk update-environment \
              --application-name Credcars-backend \
              --environment-name $EB_GREEN_ENV \
              --version-label $VERSION_LABEL

            echo "‚è≥ Waiting for GREEN environment to be healthy..."
            for i in {1..60}; do
              STATUS=$(aws elasticbeanstalk describe-environments \
                --environment-names $EB_GREEN_ENV \
                --query "Environments[0].Status" --output text)
              HEALTH=$(aws elasticbeanstalk describe-environments \
                --environment-names $EB_GREEN_ENV \
                --query "Environments[0].Health" --output text)

              echo "Status: $STATUS | Health: $HEALTH"
              if [ "$STATUS" == "Ready" ] && [ "$HEALTH" == "Green" ]; then
                echo "‚úÖ GREEN environment is ready and healthy!"
                break
              fi
              sleep 20
            done

            if [ "$STATUS" == "Ready" ] && [ "$HEALTH" == "Green" ]; then
              echo "üîÅ Swapping BLUE (live) and GREEN (new) environments..."
              aws elasticbeanstalk swap-environment-cnames \
                --source-environment-name $EB_ENV \
                --destination-environment-name $EB_GREEN_ENV
              echo "‚úÖ Swap complete. GREEN is now live."
            else
              echo "‚ùå Deployment failed. GREEN environment not healthy. No swap performed."
              exit 1
            fi
          else
            echo "üß™ Deploying to STAGING environment..."
            aws elasticbeanstalk update-environment \
              --application-name Credcars-backend \
              --environment-name $EB_ENV \
              --version-label $VERSION_LABEL
          fi

      - name: Clean up old application versions
        run: |
          echo "üßπ Cleaning up old application versions (keeping last 5)..."
          OLD_VERSIONS=$(aws elasticbeanstalk describe-application-versions \
            --application-name Credcars-backend \
            --query "ApplicationVersions[?Status=='Processed'] | sort_by(@, &DateCreated)[:-5].VersionLabel" \
            --output text)
          if [ -n "$OLD_VERSIONS" ]; then
            for VERSION in $OLD_VERSIONS; do
              echo "üóëÔ∏è Deleting old version: $VERSION"
              aws elasticbeanstalk delete-application-version \
                --application-name Credcars-backend \
                --version-label $VERSION \
                --delete-source-bundle
            done
          else
            echo "‚úÖ No old versions to delete."
          fi
